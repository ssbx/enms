@author Sebastien Serre <sserre.bx@gmail.com>
@version 0.1.0
@title Welcome to ifs (InterFace Session) application server
@doc 
<h1> Introduction </h1>
<p><b>ifs</b> is an asynchronous message dispatch application for 
communication between (n) clients and (n)application. He is responsible of:
<ul>
    <li>Authenticate client,</li>
    <li>Send messages from applications the client has subscribed on,</li>
    <li>Send messages the client is allowed to receive, following a role based
    access control,</li>
    <li>Use the encoding rules defined by the client state.</li>
</ul>
</p>
<h1> Behaviours </h1>
<p>The following behaviours permit to customise <b>ifs</b>:</p>

== beha_ifs_auth ==
<p>It is a module used to authenticate the user. More in the
<em>configuration</em> part of the doc and the {@link beha_ifs_auth} 
documentation.

</p>

== beha_ifs_module ==
<p>A Enms application producing events of interest for clients must implement 
this behaviour. More in the <em>configuration</em> part of the doc to see how 
to  add an application and the {@link beha_ifs_module} documentation for 
implementation details.</p>


== beha_ifs_encoder ==
<p>This behaviour define the encoding rules used for a client. It is stored in
the client state on the server side. There is actualy 3 module implementing
this behaviour:
<ul>
    <li><em>bifs_encoder_asn</em>: ASN BER encode/decode,</li>
    <li><em>bifs_encoder_native</em>: erlang term,</li>
</ul>

Create a new module using this behaviour has sence in the context of a custom
client. Note that a new encoder must take a <em>bifs_encoder_asn</em>
valid term and produce valid asn tuple when decoding.<br></br>
In this context, <em>ifs</em> can handle multiple clients, heach using
it's hown <em>beha_ifs_encoder</em> module thus permiting multiple encoding
rules. Because of it's complexity it is not documented nor recommended to
extend this module.
</p>

<p>Actualy there is two possibles client modules and three encoding rules. 
They use both TCP with a two bytes header length containing unsigned integers
in big-endian byte order:
<ul>
    <li><em>tcp_client</em> asn or native,</li>
    <li><em>ssl_client</em> asn or native.</li>
</ul>
</p>

<h1>About PDUs</h1>
<p>
    When adding a new application, <em>ifs</em> need to have a way to encode 
    it before sending it and decode it on receive. To do this for a simple 
    module named <em>myapp</em> for example, you will have to do the 
    following tasks:
    <ol>
        <li>
            Create a new file in the <em>ifs-x.x.x/priv/asn1/</em>:
```
$ touch ifs-x.x.x/priv/asn1/AppMyapp.asn
'''
        </li>
        <li>
            Describe the content of the PDUs. Here is a very simpler one.
            Client and server only exchange message identified by his sender
            (fromServer or fromClient) containing a <em>PrintableString</em>:

```  
$ cat ifs-x.x.x/priv/asn1/AppMyapp.asn
AppMyapp DEFINITIONS EXPLICIT TAGS ::=
BEGIN

MyappPDU    ::= CHOICE {
    fromServer  [0] PrintableString,
    fromClient  [1] PrintableString
}

END
'''
        </li>
        <li>
            Edit the NmsPDU.asn file to include your newly created ASN
            definition:
```
cat ifs-x.x.x/priv/asn1/NmsPDU.asn
NmsPDU DEFINITIONS EXPLICIT TAGS ::=
-- Use the DEFINITIONS EXPLICIT TAGS in your definition file.
-- Due to limitation in Tcl/ASN library BER encoding functions, follow these
-- rules if you plan to use it (Tkorder client use it):
-- * explicitly define tags,
-- * do not define tags in SEQUENCE constructs,
-- * do not use SET constructs.

BEGIN
IMPORTS 
    IfPDU       FROM ModIf
    EsnmpPDU    FROM ModEsnmp
    MyappPDU    FROM AppMyapp;          -- Newly added

PDU ::= CHOICE {
    modIfPDU         [0] IfPDU,
    modEsnmpPDU      [1] EsnmpPDU,
    modMyappPDU      [2] MyappPDU       -- Newly added. 
}                                       -- Note the atom *modMyappPDU* will be
                                        -- the *asnkey* for the *ifs*
END                                     -- configuration options
'''
        </li>
        <li>
            Then do a make in the <em>ifs</em> directory:
```
$ cd ifs-x.x.x/
$ make pdu
erlc -Werror -bber_bin +optimize +nif -o priv/asn1/build priv/asn1/ModIf.asn
erlc -Werror -bber_bin +optimize +nif -o priv/asn1/build priv/asn1/NmsPDU.asn
erlc -Werror -bber_bin +optimize +nif -o priv/asn1/build priv/asn1/AppMyapp.asn
erlc -Werror -bber_bin +optimize +nif -o priv/asn1/build priv/asn1/ModEsnmp.asn
'''
        </li>
        <li>
            At this point, valid tuple can be encoded and decoded using the 
            command <em>'NmsPDU':(encode | decode)/2</em> function:
```
$ erl -pa ebin
Erlang R15B02 (erts-5.9.2) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.2  (abort with ^G)
1> {ok, Pdu}  = 'NmsPDU':encode('PDU', {modMyappPDU, {fromServer, "hello from server"}}).
{ok,[<<"Â¢">>,
     [19],
     <<128>>,
     [17],
     104,101,108,108,111,32,102,114,111,109,32,115,101,114,118,
     101,114]}
2> 'NmsPDU':decode('PDU', Pdu).
{ok,{modMyappPDU,{fromServer,"hello from server"}}}
3>
'''
            Note that this command is only used now for test purpose. All the
            new added application have to do is to produce a valid term for
            'NmsPDU':encode/2 when <em>ifs</em> ask
            <em>MyappIfsModBehavior:pre_process(MyAppEvent::term())</em>, <b>
            whaterver the encoding rule defined in the configuration file</b>.
        </li>
    </ol>
</p>
<h1>Configuration </h1>
<p><em>ifs</em> uses the <em>sys.config</em> file for configuration.</p>
== General configuration ==
<p>Configuration options can be:
<ul>
<li><code>{ifs_auth, Module}</code> where Module is a module implementing the
<em>beha_ifs_auth</em> behaviour,</li>
<li><code>{tcp_client | ssl_client, Conf}</code> where conf is a list which
    can be:<ul>
    <li><code>{encoder, Encoder}</code> where Encoder is a module implementing
    the beha_ifs_encoder behaviour,</li>
    <li><code>{enabled, true | false}</code>: <em>true</em> will start the
    listener on the specified <em>port</em>,</li>
    <li><code>{port, Port}</code> where Port is an integer defining the port
    on wich the client server will listen,</li>
    <li><code>{maxconn, Max}</code> where <em>Max</em> is an integer 
    representing then maximum number of simultaneous active clients accepted
    by the listener. Each connexion ecceding this limit will clause
    immediately,
    </li>
    <li><code>{ssl_conf, TlsConf}</code> where TlsConf is the config file for 
    the ssl_client module.</li>
    </ul>
</li>
</ul>
</p>
<p>Example <em>sys.config</em> file:</p>
```
[
    ...
    {ifs,
        [
            {ifs_auth, ifs_auth_ldap},
            {tcp_client, [
                {enabled, true},
                {encoder, bifs_encoder_asn},
                {port, 8888},
                {maxconn, 50}
            ]},
            {ssl_client, [
                {enabled, true},
                {encoder, bifs_encoder_native}
                {port, 4443},
                {maxconn, 50},
                {ssl_conf, "directory/to/ssl.conf"}
            ]}
        ]
    },
    ...
].'''

== ssl_conf configuration file ==
<p>Here is an example <em>ssl_conf</em> file named <em>ssl.conf</em>:
```
cat ./ssl.conf
{certificate,   "path/to/certificate.pem"}.
{caCertificate, "path/to/request.pem"}.
{key,           "path/to/key.pem"}.
''' 
Self explanatory.
</p>

== Application events configuration ==
<p>For <em>ifs</em> to work properly, the following task must be done:
    <ul>
        <li>Register the <em>ifs_gen_event</em> on the event handler of the
        application we want to integrate,</li>
        <li>Give to <em>ifs</em> informations about the managed application:
            <ul>
                <li>The name the application will be presented to the 
                client</li>
                <li>The Asn key used by the Pdu to correctly route traffic 
                from clients </li>
                <li>The name of a callback module implementing the
                <em>beha_ifs_module</em>. It is used to: 
                    <ul>
                        <li>preprocess an event and eventualy return a tuple 
                        that can be encoded,</li>
                        <li>receive clients events, actualy commands,</li>
                        <li>receive notification of newly connected clients
                        and eventualy take further actions.</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    Example sys.config file:
</p>
```
[
    ...
    {esnmp,
        [
            {registered_events, [ifs_gen_event]}
        ]
    },
    {ifs,
        [
            {ifs_app_records, [
                {ifs_app_record, esnmp, esnmp_api_ifs, modEsnmpPDU}
            ]},
            ...
        ]
    ...
].
'''
<p>The <b>if_app_records</b> is a list of <em>#ifs_app_record</em> records
defined as followed:</p>
```
-define(ifs_app_record, {
    app_name,       % application name from the client perspective
    callback_mod,   % module implementing the beha_ifs_module behaviour
    asnkey,         % asn key
}).
'''
<p>Note that <em>it is the responsibility of the <b>esnmp</b> application to
register the <b>ifs_gen_event</b> to his event handler</em>. </p>
<p>In this specific case, the application <em>esnmp</em> uses the sys.config 
file  to be able to watch what gen_events he will have to register at
startup.</p>

@end
