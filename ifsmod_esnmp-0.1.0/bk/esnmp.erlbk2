-module(esnmp).
-compile(export_all).

-include_lib("../include/esnmp.hrl").
-include_lib("../include/qlc.hrl").

-define(DEF_AGENT_PORT, 161).

start() ->
	esnmp_init:system_boot().

which_agents() ->
	Q = qlc:q([X#snmp_agent.id || X <- mnesia:table(snmp_agent)]),
	{atomic, Rep} = mnesia:transaction(fun() -> qlc:e(Q) end),
	Rep.

register_agent(v2, Addr, Community) ->
	register_agent(v2, Addr, ?DEF_AGENT_PORT, Community).

register_agent(v2, Addr, Port, Community) ->
	register_agent(v2, Addr, Port, Community, generic_user).

register_agent(v2, Addr, Port, Community, UserMod) ->
	% la configuration existe deja?
	Id = "jojo",
	case db_agentConf_exist(Addr, Port, Community) of
		no ->
			% la configuration est acceptee par snmpm?
			case snmpm:register_agent(UserMod, Id, [{engine_id, "initial"}, {community, Community},
																	{port, Port}, {address, Addr}]) of
				ok ->
					insert_agent(v2, Addr, Port, Community, UserMod);
				Other ->
					io:format("~p ~p error: ~p", [?MODULE, ?LINE, Other])
			end
	end.

insert_agent(v2, Addr, Port, Community, UserMod) ->
	Id = "esnmp_id-" ++ esnmp_misc:generate_id(),
	Fun = fun() ->
			case mnesia:wread({snmp_agent, Id}) of
				[] ->
					Agent = #snmp_agent{id = Id, addr = Addr, port = Port, version = v2, snmpm_user = UserMod,
						community = Community, engine_id = "initial"},
					mnesia:write(Agent);
				List when is_list(List) ->
					{error, allready_registered};
				Other ->
					io:format("~p ~p error ~p~n", [?MODULE,?LINE,Other])
			end
		end,
	case mnesia:transaction(Fun) of
		{error, allready_registered} ->
			insert_agent(v2,Addr,Port,Community,UserMod);
		_Other ->
			{ok, Id}
	end.


register_agent(v3, Addr, Port, EngineId, Id, SnmpUser, noAuthNoPriv, SecName) ->
	snmpm:register_agent(SnmpUser, Id, [
		{engine_id, EngineId},
		{address, Addr},
		{port, Port},
		{version, v3},
		{sec_model, usm},
		{sec_level, noAutNoPriv},
		{sec_name, SecName}]).

register_usm_user(discover, UserName, noAuthNoPriv) ->
	EngineId = "esnmp_engineId_init-" ++ esnmp_misc:generate_id(),
	register_usm_user(EngineId, UserName, noAutNoPriv);

register_usm_user(_EngineId, _UserName, noAuthNoPriv) ->
	ok.

% get_agent_info
get_agent_info(AgentId) ->
	Q = qlc:q([X || X <- mnesia:table(snmp_agent), X#snmp_agent.id == AgentId]),
	{atomic, [AgentRecord]} = mnesia:transaction(fun() -> qlc:e(Q) end),
	AgentRecord.

% sync get
sync_get(AgentId, Oid) ->
	sync_get(generic_user, AgentId, Oid).

sync_get(SnmpmUser, AgentId, Oid) ->
	snmpm:sync_get2(SnmpmUser, AgentId, [esnmp_misc:oid_to_list(Oid)]).

% sync get bulk
sync_get_bulk(AgentId, Oid) ->
	sync_get_bulk(generic_user, AgentId, Oid).

sync_get_bulk(_SnmpmUser, _AgentId, _Oid) ->
	snmpm:sync_get_bulk2(),
	ok.

%% INTERNAL
db_agentId_lock(Id) ->
	mnesia:transaction(fun() ->
		case mnesia:wread({snmp_agent, Id}) of
			[] ->
				Agent = #snmp_agent{id = Id},
				mnesia:write(Agent);
			[A] ->
				{error, id_already_registred, A}
		end
	end).

db_agentConf_exist(Addr, Port, Community) ->
	Q = qlc:q([X#snmp_agent.id || X <- mnesia:table(snmp_agent),
		X#snmp_agent.addr == Addr,
		X#snmp_agent.port == Port,
		X#snmp_agent.community == Community]),
	case mnesia:transaction(fun() -> qlc:e(Q) end) of
		{atomic, []} ->   no;
		{atomic, [_A]} -> yes;
		_E -> {?MODULE, ?LINE, error, _E}
	end.

db_agentConf_insert(AgentRecord) ->
	mnesia:transaction(fun() -> mnesia:write(AgentRecord) end),
	{ok, AgentRecord#snmp_agent.id}.

% SNMPV3 DISCOVERY
discover_snmpv3_engineId(Addr) ->
	discover_snmpv3_engineId(Addr, ?DEF_AGENT_PORT).

discover_snmpv3_engineId(Addr, Port) ->
	snmp_target_mib:add_addr("probe_me", Addr, Port, 200, 1, "tag1", "params1", discovery, [],2048),
	Rep = snmpa:discovery("probe_me", coldStart),
	snmp_target_mib:delete_addr("probe_me"),
	Rep.
