-module(esnmp).
-compile(export_all).
-behaviour(gen_server).
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).
-export([start_link/0]).

-include_lib("../include/esnmp.hrl").
-include_lib("../include/qlc.hrl").
-include_lib("../include/snmp_types.hrl").
-define(DEF_AGENT_PORT, 161).

%% API
start_link() ->
    io:format("~p start ~n", [?MODULE]),
    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).


which_agents() ->
    Q = qlc:q([X#snmp_agent.id || X <- mnesia:table(snmp_agents)]),
    {atomic, Rep} = mnesia:transaction(fun() -> qlc:e(Q) end),
    Rep.

register_v2agent(Addr, Community) ->
    register_v2agent(Addr, ?DEF_AGENT_PORT, Community).

register_v2agent(Addr, Port, Community) ->
    register_v2agent(Addr, Port, Community, generic_user).

register_v2agent(Addr, Port, Community, UserMod) ->
    Id = lock_id(snmp_agents),
    % la configuration existe deja?
    case db_agentConf_exist(Addr, Port, Community) of
        no ->
            case snmpm:register_agent(UserMod, Id, [
                {engine_id, "initial"},
                {community, Community},
                {port, Port},
                {address, Addr}]) of
                ok ->
                    db_agentConf_insert(#snmp_agent{id = Id, engine_id = "initial",
                        snmpm_user = UserMod, addr = Addr, port = Port,
                        community = Community, version = v2});
                A ->
                    mnesia:transaction(fun() -> mnesia:delete({snmp_agents, Id}) end),
                    A
            end;
        % si oui on delocke l' Id
        yes ->
            release_id(snmp_agents, Id),
            {error, agent_already_registered}
    end.

%% GEN_SERVER CALLBACKS
init([]) ->
    io:format("~p init~n", [?MODULE]),
    % only the first time 
    % ok = init_db(),
    {ok, _} = mnesia:subscribe({table, snmp_agent, simple}),
    {ok, _} = mnesia:subscribe({table, snmp_trap,  simple}),
    {ok, []}.

handle_call(R, F, S) ->
    io:format("~p ~p ~p ~p~n", [?MODULE, ?LINE, R, F]),
    {noreply, S}.

handle_cast(R, S) ->
    io:format("~p ~p ~p ~n", [?MODULE, ?LINE, R]),
    {noreply, S}.

handle_info({mnesia_table_event, {Action, Data, _Id}}, S) ->
    % Ajouter en argument a if_switch quel module asn utiliser. Un traps n'est pas si compliquÃ© (varbinds,
    % refaire un asn pour le decrire (un comble) a moins d'arriver a en refaire un pdu et l'envoyer tel
    % quel et laisser tkorder se demeler avec sa lib snmp
    if_switch:handle_event({?MODULE, Action, Data, Data#snmp_trap.permissions}),
    {noreply, S};

handle_info(I, S) ->
    io:format("~p ~p ~p ~n", [?MODULE, ?LINE, I]),
    {noreply, S}.

terminate(R, _S) ->
    io:format("~p ~p ~p ~n", [?MODULE, ?LINE, R]),
    normal.

code_change(_O, S, _E) ->
    io:format("~p ~p ~n", [?MODULE, ?LINE]),
    {ok, S}.


%% INTERNAL
init_db() ->
    IsRunning       = mnesia:system_info(is_running),
    DirUsed         = mnesia:system_info(use_dir),
    if IsRunning    == yes  -> mnesia:stop(); true -> ok end,
    if DirUsed      == true -> mnesia:delete_schema([node()]); true -> ok end,
    ok  = mnesia:create_schema([node()]),
    ok  = mnesia:start(),
    {atomic, ok} = mnesia:create_table(snmp_agent, [{attributes, record_info(fields, snmp_agent)},
            {record_name, snmp_agent}, {disc_copies, [node()]}]),
    {atomic, ok} = mnesia:create_table(snmp_trap, [{attributes, record_info(fields, snmp_trap)},
            {record_name, snmp_trap}, {disc_copies, [node()]}]),
    ok.

% get_agent_info
get_agent_info(AgentId) ->
    Q = qlc:q([X || X <- mnesia:table(snmp_agents), X#snmp_agent.id == AgentId]),
    {atomic, [AgentRecord]} = mnesia:transaction(fun() -> qlc:e(Q) end),
    AgentRecord.

db_agentConf_exist(Addr, Port, Community) ->
    Q = qlc:q([X#snmp_agent.id || X <- mnesia:table(snmp_agents),
        X#snmp_agent.addr == Addr,
        X#snmp_agent.port == Port,
        X#snmp_agent.community == Community]),
    case mnesia:transaction(fun() -> qlc:e(Q) end) of
        {atomic, []} ->   no;
        {atomic, [_A]} -> yes;
        _E -> {?MODULE, ?LINE, error, _E}
    end.

db_agentConf_insert(AgentRecord) ->
    mnesia:transaction(fun() -> mnesia:write(snmp_agents, AgentRecord, write) end),
    {ok, AgentRecord#snmp_agent.id}.

lock_id(snmp_agents) ->
    NewId = "esnmp_agentId-" ++ esnmp_misc:generate_id(),
    {atomic, Rep} = mnesia:transaction(fun() ->
        case mnesia:wread({snmp_agents, NewId}) of
            [] ->
                Agent = #snmp_agent{id = NewId},
                ok = mnesia:write(snmp_agents, Agent, write);
            [_Other] ->
                error
        end
    end),
    case Rep of
        ok -> NewId;
        error -> lock_id(snmp_agents)
    end.

release_id(Table, Id) ->
    mnesia:transaction(fun() -> mnesia:delete({Table, Id}) end).
