% This file is part of "Enms" (http://sourceforge.net/projects/enms/)
% Copyright (C) 2012 <SÃ©bastien Serre sserre.bx@gmail.com>
% 
% Enms is a Network Management System aimed to manage and monitor SNMP
% targets, monitor network hosts and services, provide a consistent
% documentation system and tools to help network professionals
% to have a wide perspective of the networks they manage.
% 
% Enms is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% Enms is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with Enms.  If not, see <http://www.gnu.org/licenses/>.
% @doc ifs_endpoint process message issuing by the client destined to the ifs module
-module(ifs_endpoint).
-include_lib("../include/client_state.hrl").

% API
-export([handle/2]).

-define(AUTH_MOD, bifs_auth_local).
    
% @doc handle message from server
handle({fromClient, {authRep, {ldap, {_, UName, UPass}}}}, #client_state{module = Mod} = SocketState) ->
    case ?AUTH_MOD:authenticate(UName, UPass) of
        {ok, Roles} ->
            gen_server:cast(?MODULE, {send_ack, Roles, SocketState, UName});
        fail ->
            Mod:send(SocketState, {modIfPDU, {fromServer, {authError,
                    {'AuthPDU_fromServer_authError', badPass, UName, UPass}}}});
        Other ->
            io:format("unknown ~p in ~p line ~p~n", [Other, ?MODULE, ?LINE])
    end;

handle({fromClient, {subscribe, Mods}}, #client_state{state = 'RUNNING'} = SocketState) ->
    lists:foreach(fun(X) -> 
        Mod = erlang:list_to_atom(X),
        Mod:init_client(SocketState),
        ifs_mpd:register_client(SocketState, X) 
    end, Mods);

handle({fromClient, {unsubscribe, Mods}}, #client_state{state = 'RUNNING'} = SocketState) ->
    lists:foreach(fun(X) -> ifs_mpd:unregister_client(SocketState, X) end, Mods);

handle({fromClient, {connect}}, #client_state{module = Module} = SocketState) ->
    Module:send(SocketState, {modIfPDU, {fromServer, {authReq, ldap}}});

handle({fromClient, {disconnect}}, SocketState) ->
    ifs_mpd:del_client(SocketState);

handle(A, S) ->
    io:format("ici ~p ~p~n", [A,S]).
    

handle_cast({send_ack, Roles, #client_state{module = CliMod} = SocketState, UName}, S) ->
    Modules = lists:map(fun(X) -> 
        erlang:atom_to_list(X#if_module.callback_mod) 
    end, S#if_server_state.modules),
    NewSocketState  = SocketState#client_state{user_roles = Roles, user_name = UName},
    CliMod:auth_set(auth_success, NewSocketState),
    CliMod:send(NewSocketState, {modIfPDU, {fromServer, {authAck,
            {'AuthPDU_fromServer_authAck', Roles, Modules}}}}),
    {noreply, S}.
