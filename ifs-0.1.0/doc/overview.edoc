@author Sebastien Serre <sserre.bx@gmail.com>
@version 0.1.0
@title Welcome to ifs (InterFace Session) application server
@doc 
<h1> Introduction </h1>
<p><b>ifs</b> is an asynchronous message dispatch module for communication
between (n) clients and (n) modules. He is responsible of:
<ul>
    <li>Authenticate client,</li>
    <li>Send messages from modules the client has subscribed on,</li>
    <li>Send messages the client is allowed to receive, following a role based
    access control,</li>
    <li>Use the encoding rules defined by the client state.</li>
</ul>
</p>
<h1> Behaviours </h1>
<p>The following behaviours permit to customise <b>ifs</b>:</p>

== beha_ifs_auth ==
<p>It is the module used to authenticate the user. <b>ifs</b> do a
<em>Mod:authenticate/2</em> on user credentials submit.
</p>

== beha_ifs_module ==
<p>A Enms module producing events of interest for clients must implement this
behaviour. See the <em>configuration</em> part of the doc to see how to add an
event module.</p>


== beha_ifs_encoder ==
<p>This behaviour define the encoding rules used for a client. It is stored in
the client state on the server side. There is actualy 3 module implementing
this behaviour:
<ul>
    <li><em>bifs_encoder_asn</em>: ASN BER encode/decode,</li>
    <li><em>bifs_encoder_native</em>: erlang term,</li>
    <li><em>bifs_encoder_xml</em>: xml term.</li>
</ul>

Create a new module using this behaviour has sence in the context of a custom
client module. Note that a new encoder must take a <em>bifs_encoder_asn</em>
valid term and produce valid asn tuple when decoding.<br></br>
In this context, <em>ifs</em> can handle multiple clients, heach using
it's hown <em>beha_ifs_encoder</em> module thus permiting multiple encoding
rules. Because of it's complexity it is not documented nor recommended to
extend this module.
</p>

<p>Actualy there si two possibles client modules and three encoding rules:
<ul>
    <li><em>tcp_client</em> using asn, native or xml,</li>
    <li><em>ssl_client</em> using asn, native or xml.</li>
</ul>
</p>

<h1>About PDUs</h1>
<p>
    When adding a new module, <em>ifs</em> need to have a way to encode it
    before sending it and decode it on receive. To do this for a simple module
    named <em>mymodule</em> for example, you will have to do the following
    tasks:
    <ol>
        <li>
            Create a new file in the <em>ifs-x.x.x/priv/asn1/</em>:
```
$ touch ifs-x.x.x/priv/asn1/ModMymod.asn
'''
        </li>
        <li>
            Describe the content of the PDUs. Here is a very simpler one.
            Client and server only exchange message identified by his sender
            (fromServer or fromClient) containing a <em>PrintableString</em>:

```  
$ cat ifs-x.x.x/priv/asn1/ModMymod.asn
ModMymod DEFINITIONS AUTOMATIC TAGS ::=
BEGIN

MymodPDU    ::= CHOICE {
    fromServer  PrintableString,
    fromClient  PrintableString
}

END
'''
        </li>
        <li>
            Edit the NmsPDU.asn description file to include your newly created
            module PDU:
```
cat ifs-x.x.x/priv/asn1/NmsPDU.asn
BEGIN
IMPORTS 
    IfPDU       FROM ModIf
    EsnmpPDU    FROM ModEsnmp
    MymodPDU    FROM ModMymod;      -- Newly added

PDU ::= CHOICE {
    modIfPDU         IfPDU,
    modEsnmpPDU      EsnmpPDU,
    modMymodPDU      MymodPDU       -- Newly added. 
}                                   -- Note the atom *modMymodPDU* will be
                                    -- the *asnkey* for the *ifs*
END                                 -- configuration options
'''
        </li>
        <li>
            Then do a make in the <em>ifs</em> directory:
```
$ cd ifs-x.x.x/
$ make pdu
erlc -Werror -bber_bin +optimize +nif -o priv/asn1/build priv/asn1/ModIf.asn
erlc -Werror -bber_bin +optimize +nif -o priv/asn1/build priv/asn1/NmsPDU.asn
erlc -Werror -bber_bin +optimize +nif -o priv/asn1/build priv/asn1/ModMymod.asn
erlc -Werror -bber_bin +optimize +nif -o priv/asn1/build priv/asn1/ModEsnmp.asn
'''
        </li>
        <li>
            At this point, valid tuple can be encoded and decoded using the 
            command <em>'NmsPDU':(encode | decode)/2</em> function:
```
$ erl -pa ebin
Erlang R15B02 (erts-5.9.2) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.2  (abort with ^G)
1> {ok, Pdu}  = 'NmsPDU':encode('PDU', {modMymodPDU, {fromServer, "hello from server"}}).
{ok,[<<"Â¢">>,
     [19],
     <<128>>,
     [17],
     104,101,108,108,111,32,102,114,111,109,32,115,101,114,118,
     101,114]}
2> 'NmsPDU':decode('PDU', Pdu).
{ok,{modMymodPDU,{fromServer,"hello from server"}}}
3>
'''
            Note that this command is only used now for test purpose. All the
            new added module have to do is to produce a valid term for
            'NmsPDU':encode/2 when <em>ifs</em> ask
            <em>MymodIfsModBehavior:pre_process(MyModEvent::term())</em>, <b>
            whaterver the encoding rule defined in the configuration file</b>.
        </li>
    </ol>
</p>
<h1>Configuration </h1>
<p><em>ifs</em> uses the <em>sys.config</em> file for configuration.</p>
== General configuration ==
<p>Configuration options can be:
<ul>
<li><code>{ifs_auth, Module}</code> where Module is a module implementing the
<em>beha_ifs_auth</em> behaviour,</li>
<li><code>{tcp_client | ssl_client, Conf}</code> where conf is a list which
    can be:<ul>
    <li><code>{encoder, Encoder}</code> where Encoder is a module implementing
    the beha_ifs_encoder behaviour,</li>
    <li><code>{enabled, true | false}</code>: <em>true</em> will start the
    listener on the specified <em>port</em>,</li>
    <li><code>{port, Port}</code> where Port is an integer defining the port
    on wich the client module will listen,</li>
    <li><code>{maxconn, Max}</code> where <em>Max</em> is an integer 
    representing then maximum number of simultaneous active clients accepted
    by the listener. Each connexion ecceding this limit will clause
    immediately,
    </li>
    <li><code>{ssl_conf, TlsConf}</code> where TlsConf is the config file for 
    the ssl_client module.</li>
    </ul>
</li>
</ul>
</p>
<p>Example <em>sys.config</em> file:</p>
```
[
    ...
    {ifs,
        [
            {ifs_auth, ifs_auth_ldap},
            {tcp_client, [
                {enabled, true},
                {encoder, bifs_encoder_asn},
                {port, 8888},
                {maxconn, 50}
            ]},
            {ssl_client, [
                {enabled, true},
                {encoder, bifs_encoder_native}
                {port, 4443},
                {maxconn, 50},
                {ssl_conf, "directory/to/ssl.conf"}
            ]}
        ]
    },
    ...
].'''
== Module events configuration ==
<p>For <em>ifs</em> to work properly, the following task must be done:
    <ul>
        <li>Register the <em>ifs_gen_event</em> on the event handler of the
        module we want to integrate,</li>
        <li>Give to <em>ifs</em> informations about the managed module:
            <ul>
                <li>The name the module will be presented to the client</li>
                <li>The Asn key used by the Pdu to correctly route traffic 
                from clients </li>
                <li>The name of a callback module implementing the
                <em>beha_ifs_module</em>. It is used to: 
                    <ul>
                        <li>preprocess an event and eventualy return a tuple 
                        that can be encoded,</li>
                        <li>receive clients events, actualy commands,</li>
                        <li>receive notification of newly connected clients
                        and eventualy take further actions.</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    Example sys.config file:
</p>
```
[
    ...
    {esnmp,
        [
            {registered_events, [ifs_gen_event]}
        ]
    },
    {ifs,
        [
            {if_module_records, [
                {if_module, esnmp, esnmp_api_ifs, modEsnmpPDU}
            ]},
            ...
        ]
    ...
].
'''
<p>The <b>if_module_records</b> is a list of <em>#if_module</em> records
defined as followed:</p>
```
-define(if_module, {
    module_name,    % module name from the client perspective
    callback_mod,   % module implementing the beha_ifs_module behaviour
    asnkey,         % asn key
}).
'''
<p>Note that <em>it is the responsibility of the <b>esnmp</b> module to 
register the <b>ifs_gen_event</b> to his event handler</em>. </p>
<p>In this specific case, the module <em>esnmp</em> uses the sys.config file 
to be able to watch what gen_events he will have to register at startup.</p>

== ssl_conf configuration file ==
<p>Here is an example <em>ssl_conf</em> file named <em>ssl.conf</em>:
```
cat ./ssl.conf
{certificate,   "path/to/certificate.pem"}.
{caCertificate, "path/to/request.pem"}.
{key,           "path/to/key.pem"}.
''' 
Self explanatory.
</p>
@end
