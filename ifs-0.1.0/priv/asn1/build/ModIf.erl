%% Generated by the Erlang ASN.1 BER_V2-compiler version, utilizing bit-syntax:1.8
%% Purpose: encoder and decoder to the types in mod ModIf

-module('ModIf').
-include("ModIf.hrl").
-define('RT_BER',asn1rt_ber_bin_v2).
-asn1_info([{vsn,'1.8'},
            {module,'ModIf'},
            {options,[{i,[47,104,111,109,101,47,115,101,98,47,115,114,99,47,110,109,115,95,112,114,111,106,101,99,116,45,48,46,49,46,48,47,105,102,115,45,48,46,49,46,48,47,112,114,105,118,47,97,115,110,49,47,98,117,105,108,100]},ber_bin_v2,warnings,errors,{cwd,[47,104,111,109,101,47,115,101,98,47,115,114,99,47,110,109,115,95,112,114,111,106,101,99,116,45,48,46,49,46,48,47,105,102,115,45,48,46,49,46,48]},{outdir,[47,104,111,109,101,47,115,101,98,47,115,114,99,47,110,109,115,95,112,114,111,106,101,99,116,45,48,46,49,46,48,47,105,102,115,45,48,46,49,46,48,47,112,114,105,118,47,97,115,110,49,47,98,117,105,108,100]},nif,optimize,{i,[46]},{i,[47,104,111,109,101,47,115,101,98,47,115,114,99,47,110,109,115,95,112,114,111,106,101,99,116,45,48,46,49,46,48,47,105,102,115,45,48,46,49,46,48,47,112,114,105,118,47,97,115,110,49]}]}]).

-export([encoding_rule/0]).
-export([
'enc_Version'/2,
'enc_Groups'/2,
'enc_Group'/2,
'enc_Modules'/2,
'enc_Module'/2,
'enc_UserID'/2,
'enc_UserPasswd'/2,
'enc_AuthProtos'/2,
'enc_AuthProto'/2,
'enc_Error'/2,
'enc_IfPDU'/2
]).

-export([
'dec_Version'/2,
'dec_Groups'/2,
'dec_Group'/2,
'dec_Modules'/2,
'dec_Module'/2,
'dec_UserID'/2,
'dec_UserPasswd'/2,
'dec_AuthProtos'/2,
'dec_AuthProto'/2,
'dec_Error'/2,
'dec_IfPDU'/2
]).

-export([info/0]).


-export([encode/2,decode/2,encode_disp/2,decode_disp/2]).

encoding_rule() ->
   ber_bin_v2.

encode(Type,Data) ->
case catch encode_disp(Type,Data) of
  {'EXIT',{error,Reason}} ->
    {error,Reason};
  {'EXIT',Reason} ->
    {error,{asn1,Reason}};
  {Bytes,_Len} ->
    {ok,Bytes};
  Bytes ->
    {ok,Bytes}
end.

decode(Type,Data) ->
case catch decode_disp(Type,element(1,?RT_BER:decode(Data,nif))
) of
  {'EXIT',{error,Reason}} ->
    {error,Reason};
  {'EXIT',Reason} ->
    {error,{asn1,Reason}};
  Result ->
    {ok,Result}
end.

encode_disp('Version',Data) -> 'enc_Version'(Data);
encode_disp('Groups',Data) -> 'enc_Groups'(Data);
encode_disp('Group',Data) -> 'enc_Group'(Data);
encode_disp('Modules',Data) -> 'enc_Modules'(Data);
encode_disp('Module',Data) -> 'enc_Module'(Data);
encode_disp('UserID',Data) -> 'enc_UserID'(Data);
encode_disp('UserPasswd',Data) -> 'enc_UserPasswd'(Data);
encode_disp('AuthProtos',Data) -> 'enc_AuthProtos'(Data);
encode_disp('AuthProto',Data) -> 'enc_AuthProto'(Data);
encode_disp('Error',Data) -> 'enc_Error'(Data);
encode_disp('IfPDU',Data) -> 'enc_IfPDU'(Data);
encode_disp(Type,_Data) -> exit({error,{asn1,{undefined_type,Type}}}).


decode_disp('Version',Data) -> 'dec_Version'(Data);
decode_disp('Groups',Data) -> 'dec_Groups'(Data);
decode_disp('Group',Data) -> 'dec_Group'(Data);
decode_disp('Modules',Data) -> 'dec_Modules'(Data);
decode_disp('Module',Data) -> 'dec_Module'(Data);
decode_disp('UserID',Data) -> 'dec_UserID'(Data);
decode_disp('UserPasswd',Data) -> 'dec_UserPasswd'(Data);
decode_disp('AuthProtos',Data) -> 'dec_AuthProtos'(Data);
decode_disp('AuthProto',Data) -> 'dec_AuthProto'(Data);
decode_disp('Error',Data) -> 'dec_Error'(Data);
decode_disp('IfPDU',Data) -> 'dec_IfPDU'(Data);
decode_disp(Type,_Data) -> exit({error,{asn1,{undefined_type,Type}}}).





info() ->
   case ?MODULE:module_info() of
      MI when is_list(MI) ->
         case lists:keysearch(attributes,1,MI) of
            {value,{_,Attributes}} when is_list(Attributes) ->
               case lists:keysearch(asn1_info,1,Attributes) of
                  {value,{_,Info}} when is_list(Info) ->
                     Info;
                  _ ->
                     []
               end;
            _ ->
               []
         end
   end.


%%================================
%%  Version
%%================================
'enc_Version'(Val) ->
    'enc_Version'(Val, [<<48>>]).

'enc_Version'(Val, TagIn) ->
{_,Cindex1, Cindex2, Cindex3} = Val,

%%-------------------------------------------------
%% attribute major(1) with type INTEGER
%%-------------------------------------------------
   {EncBytes1,EncLen1} = ?RT_BER:encode_integer([], Cindex1, [<<128>>]),

%%-------------------------------------------------
%% attribute minor(2) with type INTEGER
%%-------------------------------------------------
   {EncBytes2,EncLen2} = ?RT_BER:encode_integer([], Cindex2, [<<129>>]),

%%-------------------------------------------------
%% attribute patch(3) with type INTEGER
%%-------------------------------------------------
   {EncBytes3,EncLen3} = ?RT_BER:encode_integer([], Cindex3, [<<130>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
?RT_BER:encode_tags(TagIn, BytesSoFar, LenSoFar).


'dec_Version'(Tlv) ->
   'dec_Version'(Tlv, [16]).

'dec_Version'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 

%%-------------------------------------------------
%% attribute major(1) with type INTEGER
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = ?RT_BER:decode_integer(V1,[],[131072]),

%%-------------------------------------------------
%% attribute minor(2) with type INTEGER
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = ?RT_BER:decode_integer(V2,[],[131073]),

%%-------------------------------------------------
%% attribute patch(3) with type INTEGER
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = ?RT_BER:decode_integer(V3,[],[131074]),

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
   {'Version', Term1, Term2, Term3}.



%%================================
%%  Groups
%%================================
'enc_Groups'(Val) ->
    'enc_Groups'(Val, [<<48>>]).


'enc_Groups'({'Groups',Val}, TagIn) ->
   'enc_Groups'(Val, TagIn);

'enc_Groups'(Val, TagIn) ->
   {EncBytes,EncLen} = 'enc_Groups_components'(Val,[],0),
   ?RT_BER:encode_tags(TagIn, EncBytes, EncLen).

'enc_Groups_components'([], AccBytes, AccLen) -> 
   {lists:reverse(AccBytes),AccLen};

'enc_Groups_components'([H|T],AccBytes, AccLen) ->
   {EncBytes,EncLen} = ?RT_BER:encode_restricted_string([], H, 19, [<<19>>]),
   'enc_Groups_components'(T,[EncBytes|AccBytes], AccLen + EncLen).



'dec_Groups'(Tlv) ->
   'dec_Groups'(Tlv, [16]).

'dec_Groups'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 
[?RT_BER:decode_restricted_string(V1,{1,50},19,[19]) || V1 <- Tlv1].




%%================================
%%  Group
%%================================
'enc_Group'(Val) ->
    'enc_Group'(Val, [<<19>>]).


'enc_Group'({'Group',Val}, TagIn) ->
   'enc_Group'(Val, TagIn);

'enc_Group'(Val, TagIn) ->
?RT_BER:encode_restricted_string([], Val, 19, TagIn).


'dec_Group'(Tlv) ->
   'dec_Group'(Tlv, [19]).

'dec_Group'(Tlv, TagIn) ->
?RT_BER:decode_restricted_string(Tlv,{1,50},19,TagIn).



%%================================
%%  Modules
%%================================
'enc_Modules'(Val) ->
    'enc_Modules'(Val, [<<48>>]).


'enc_Modules'({'Modules',Val}, TagIn) ->
   'enc_Modules'(Val, TagIn);

'enc_Modules'(Val, TagIn) ->
   {EncBytes,EncLen} = 'enc_Modules_components'(Val,[],0),
   ?RT_BER:encode_tags(TagIn, EncBytes, EncLen).

'enc_Modules_components'([], AccBytes, AccLen) -> 
   {lists:reverse(AccBytes),AccLen};

'enc_Modules_components'([H|T],AccBytes, AccLen) ->
   {EncBytes,EncLen} = ?RT_BER:encode_restricted_string([], H, 19, [<<19>>]),
   'enc_Modules_components'(T,[EncBytes|AccBytes], AccLen + EncLen).



'dec_Modules'(Tlv) ->
   'dec_Modules'(Tlv, [16]).

'dec_Modules'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 
[?RT_BER:decode_restricted_string(V1,{1,30},19,[19]) || V1 <- Tlv1].




%%================================
%%  Module
%%================================
'enc_Module'(Val) ->
    'enc_Module'(Val, [<<19>>]).


'enc_Module'({'Module',Val}, TagIn) ->
   'enc_Module'(Val, TagIn);

'enc_Module'(Val, TagIn) ->
?RT_BER:encode_restricted_string([], Val, 19, TagIn).


'dec_Module'(Tlv) ->
   'dec_Module'(Tlv, [19]).

'dec_Module'(Tlv, TagIn) ->
?RT_BER:decode_restricted_string(Tlv,{1,30},19,TagIn).



%%================================
%%  UserID
%%================================
'enc_UserID'(Val) ->
    'enc_UserID'(Val, [<<19>>]).


'enc_UserID'({'UserID',Val}, TagIn) ->
   'enc_UserID'(Val, TagIn);

'enc_UserID'(Val, TagIn) ->
?RT_BER:encode_restricted_string([], Val, 19, TagIn).


'dec_UserID'(Tlv) ->
   'dec_UserID'(Tlv, [19]).

'dec_UserID'(Tlv, TagIn) ->
?RT_BER:decode_restricted_string(Tlv,{1,30},19,TagIn).



%%================================
%%  UserPasswd
%%================================
'enc_UserPasswd'(Val) ->
    'enc_UserPasswd'(Val, [<<19>>]).


'enc_UserPasswd'({'UserPasswd',Val}, TagIn) ->
   'enc_UserPasswd'(Val, TagIn);

'enc_UserPasswd'(Val, TagIn) ->
?RT_BER:encode_restricted_string([], Val, 19, TagIn).


'dec_UserPasswd'(Tlv) ->
   'dec_UserPasswd'(Tlv, [19]).

'dec_UserPasswd'(Tlv, TagIn) ->
?RT_BER:decode_restricted_string(Tlv,{1,30},19,TagIn).



%%================================
%%  AuthProtos
%%================================
'enc_AuthProtos'(Val) ->
    'enc_AuthProtos'(Val, [<<48>>]).


'enc_AuthProtos'({'AuthProtos',Val}, TagIn) ->
   'enc_AuthProtos'(Val, TagIn);

'enc_AuthProtos'(Val, TagIn) ->
   {EncBytes,EncLen} = 'enc_AuthProtos_components'(Val,[],0),
   ?RT_BER:encode_tags(TagIn, EncBytes, EncLen).

'enc_AuthProtos_components'([], AccBytes, AccLen) -> 
   {lists:reverse(AccBytes),AccLen};

'enc_AuthProtos_components'([H|T],AccBytes, AccLen) ->
   {EncBytes,EncLen} = case H of
localFile -> ?RT_BER:encode_enumerated(0,[<<10>>]);
ldap -> ?RT_BER:encode_enumerated(1,[<<10>>]);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end,
   'enc_AuthProtos_components'(T,[EncBytes|AccBytes], AccLen + EncLen).



'dec_AuthProtos'(Tlv) ->
   'dec_AuthProtos'(Tlv, [16]).

'dec_AuthProtos'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 
[?RT_BER:decode_enumerated(V1,[],[{localFile,0},{ldap,1}],[10]) || V1 <- Tlv1].




%%================================
%%  AuthProto
%%================================
'enc_AuthProto'(Val) ->
    'enc_AuthProto'(Val, [<<10>>]).


'enc_AuthProto'({'AuthProto',Val}, TagIn) ->
   'enc_AuthProto'(Val, TagIn);

'enc_AuthProto'(Val, TagIn) ->
case Val of
localFile -> ?RT_BER:encode_enumerated(0,TagIn);
ldap -> ?RT_BER:encode_enumerated(1,TagIn);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end.


'dec_AuthProto'(Tlv) ->
   'dec_AuthProto'(Tlv, [10]).

'dec_AuthProto'(Tlv, TagIn) ->
?RT_BER:decode_enumerated(Tlv,[],[{localFile,0},{ldap,1}],TagIn).



%%================================
%%  Error
%%================================
'enc_Error'(Val) ->
    'enc_Error'(Val, [<<10>>]).


'enc_Error'({'Error',Val}, TagIn) ->
   'enc_Error'(Val, TagIn);

'enc_Error'(Val, TagIn) ->
case Val of
noSuchUser -> ?RT_BER:encode_enumerated(0,TagIn);
badPass -> ?RT_BER:encode_enumerated(1,TagIn);
timeout -> ?RT_BER:encode_enumerated(2,TagIn);
other -> ?RT_BER:encode_enumerated(3,TagIn);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end.


'dec_Error'(Tlv) ->
   'dec_Error'(Tlv, [10]).

'dec_Error'(Tlv, TagIn) ->
?RT_BER:decode_enumerated(Tlv,[],[{noSuchUser,0},{badPass,1},{timeout,2},{other,3}],TagIn).



%%================================
%%  IfPDU
%%================================
'enc_IfPDU'(Val) ->
    'enc_IfPDU'(Val, []).


'enc_IfPDU'({'IfPDU',Val}, TagIn) ->
   'enc_IfPDU'(Val, TagIn);

'enc_IfPDU'(Val, TagIn) ->
   {EncBytes,EncLen} = case element(1,Val) of
      fromServer ->
         'enc_IfPDU_fromServer'(element(2,Val), [<<160>>]);
      fromClient ->
         'enc_IfPDU_fromClient'(element(2,Val), [<<161>>]);
      Else -> 
         exit({error,{asn1,{invalid_choice_type,Else}}})
   end,

?RT_BER:encode_tags(TagIn, EncBytes, EncLen).





%%================================
%%  IfPDU_fromServer
%%================================

'enc_IfPDU_fromServer'({'IfPDU_fromServer',Val}, TagIn) ->
   'enc_IfPDU_fromServer'(Val, TagIn);

'enc_IfPDU_fromServer'(Val, TagIn) ->
      {EncBytes,EncLen} = case element(1,Val) of
      version ->
         'enc_Version'(element(2,Val), [<<160>>]);
      authProtos ->
         'enc_AuthProtos'(element(2,Val), [<<161>>]);
      authReq ->
         case element(2,Val) of
localFile -> ?RT_BER:encode_enumerated(0,[<<130>>]);
ldap -> ?RT_BER:encode_enumerated(1,[<<130>>]);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end;
      authAck ->
         'enc_IfPDU_fromServer_authAck'(element(2,Val), [<<163>>]);
      authError ->
         'enc_IfPDU_fromServer_authError'(element(2,Val), [<<164>>]);
      subscribeOk ->
         ?RT_BER:encode_restricted_string([], element(2,Val), 19, [<<133>>]);
      Else -> 
         exit({error,{asn1,{invalid_choice_type,Else}}})
   end,

?RT_BER:encode_tags(TagIn, EncBytes, EncLen).





%%================================
%%  IfPDU_fromServer_authAck
%%================================
'enc_IfPDU_fromServer_authAck'(Val, TagIn) ->
   {_,Cindex1, Cindex2} = Val,

%%-------------------------------------------------
%% attribute groups(1)   External ModIf:Groups
%%-------------------------------------------------
   {EncBytes1,EncLen1} = 'enc_Groups'(Cindex1, [<<160>>]),

%%-------------------------------------------------
%% attribute modules(2)   External ModIf:Modules
%%-------------------------------------------------
   {EncBytes2,EncLen2} = 'enc_Modules'(Cindex2, [<<161>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
?RT_BER:encode_tags(TagIn, BytesSoFar, LenSoFar).
'dec_IfPDU_fromServer_authAck'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 

%%-------------------------------------------------
%% attribute groups(1)   External ModIf:Groups
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = 'dec_Groups'(V1, [131072]),

%%-------------------------------------------------
%% attribute modules(2)   External ModIf:Modules
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = 'dec_Modules'(V2, [131073]),

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
   {'IfPDU_fromServer_authAck', Term1, Term2}.




%%================================
%%  IfPDU_fromServer_authError
%%================================
'enc_IfPDU_fromServer_authError'(Val, TagIn) ->
   {_,Cindex1, Cindex2, Cindex3} = Val,

%%-------------------------------------------------
%% attribute error(1) with type ENUMERATED
%%-------------------------------------------------
   {EncBytes1,EncLen1} = case Cindex1 of
noSuchUser -> ?RT_BER:encode_enumerated(0,[<<128>>]);
badPass -> ?RT_BER:encode_enumerated(1,[<<128>>]);
timeout -> ?RT_BER:encode_enumerated(2,[<<128>>]);
other -> ?RT_BER:encode_enumerated(3,[<<128>>]);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end,

%%-------------------------------------------------
%% attribute userId(2) with type PrintableString
%%-------------------------------------------------
   {EncBytes2,EncLen2} = ?RT_BER:encode_restricted_string([], Cindex2, 19, [<<129>>]),

%%-------------------------------------------------
%% attribute pass(3) with type PrintableString
%%-------------------------------------------------
   {EncBytes3,EncLen3} = ?RT_BER:encode_restricted_string([], Cindex3, 19, [<<130>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
?RT_BER:encode_tags(TagIn, BytesSoFar, LenSoFar).
'dec_IfPDU_fromServer_authError'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 

%%-------------------------------------------------
%% attribute error(1) with type ENUMERATED
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = ?RT_BER:decode_enumerated(V1,[],[{noSuchUser,0},{badPass,1},{timeout,2},{other,3}],[131072]),

%%-------------------------------------------------
%% attribute userId(2) with type PrintableString
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = ?RT_BER:decode_restricted_string(V2,{1,30},19,[131073]),

%%-------------------------------------------------
%% attribute pass(3) with type PrintableString
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = ?RT_BER:decode_restricted_string(V3,{1,30},19,[131074]),

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
   {'IfPDU_fromServer_authError', Term1, Term2, Term3}.

'dec_IfPDU_fromServer'(Tlv, TagIn) ->
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 
case (case Tlv1 of [CtempTlv1] -> CtempTlv1; _ -> Tlv1 end) of

%% 'version'
    {131072, V1} -> 
        {version, 'dec_Version'(V1, [])};


%% 'authProtos'
    {131073, V1} -> 
        {authProtos, 'dec_AuthProtos'(V1, [])};


%% 'authReq'
    {131074, V1} -> 
        {authReq, ?RT_BER:decode_enumerated(V1,[],[{localFile,0},{ldap,1}],[])};


%% 'authAck'
    {131075, V1} -> 
        {authAck, 'dec_IfPDU_fromServer_authAck'(V1, [])};


%% 'authError'
    {131076, V1} -> 
        {authError, 'dec_IfPDU_fromServer_authError'(V1, [])};


%% 'subscribeOk'
    {131077, V1} -> 
        {subscribeOk, ?RT_BER:decode_restricted_string(V1,{1,30},19,[])};

      Else -> 
         {asn1_ExtAlt, ?RT_BER:encode(Else,nif)}
   end
.



%%================================
%%  IfPDU_fromClient
%%================================

'enc_IfPDU_fromClient'({'IfPDU_fromClient',Val}, TagIn) ->
   'enc_IfPDU_fromClient'(Val, TagIn);

'enc_IfPDU_fromClient'(Val, TagIn) ->
      {EncBytes,EncLen} = case element(1,Val) of
      subscribe ->
         'enc_Modules'(element(2,Val), [<<160>>]);
      unsubscribe ->
         'enc_Modules'(element(2,Val), [<<161>>]);
      version ->
         'enc_Version'(element(2,Val), [<<162>>]);
      authProto ->
         case element(2,Val) of
localFile -> ?RT_BER:encode_enumerated(0,[<<131>>]);
ldap -> ?RT_BER:encode_enumerated(1,[<<131>>]);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end;
      authRep ->
         'enc_IfPDU_fromClient_authRep'(element(2,Val), [<<164>>]);
      Else -> 
         exit({error,{asn1,{invalid_choice_type,Else}}})
   end,

?RT_BER:encode_tags(TagIn, EncBytes, EncLen).





%%================================
%%  IfPDU_fromClient_authRep
%%================================

'enc_IfPDU_fromClient_authRep'({'IfPDU_fromClient_authRep',Val}, TagIn) ->
   'enc_IfPDU_fromClient_authRep'(Val, TagIn);

'enc_IfPDU_fromClient_authRep'(Val, TagIn) ->
      {EncBytes,EncLen} = case element(1,Val) of
      localFile ->
         'enc_IfPDU_fromClient_authRep_localFile'(element(2,Val), [<<160>>]);
      ldap ->
         'enc_IfPDU_fromClient_authRep_ldap'(element(2,Val), [<<161>>]);
      Else -> 
         exit({error,{asn1,{invalid_choice_type,Else}}})
   end,

?RT_BER:encode_tags(TagIn, EncBytes, EncLen).





%%================================
%%  IfPDU_fromClient_authRep_localFile
%%================================
'enc_IfPDU_fromClient_authRep_localFile'(Val, TagIn) ->
   {_,Cindex1, Cindex2} = Val,

%%-------------------------------------------------
%% attribute userId(1) with type PrintableString
%%-------------------------------------------------
   {EncBytes1,EncLen1} = ?RT_BER:encode_restricted_string([], Cindex1, 19, [<<128>>]),

%%-------------------------------------------------
%% attribute pass(2) with type PrintableString
%%-------------------------------------------------
   {EncBytes2,EncLen2} = ?RT_BER:encode_restricted_string([], Cindex2, 19, [<<129>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
?RT_BER:encode_tags(TagIn, BytesSoFar, LenSoFar).
'dec_IfPDU_fromClient_authRep_localFile'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 

%%-------------------------------------------------
%% attribute userId(1) with type PrintableString
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = ?RT_BER:decode_restricted_string(V1,{1,30},19,[131072]),

%%-------------------------------------------------
%% attribute pass(2) with type PrintableString
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = ?RT_BER:decode_restricted_string(V2,{1,30},19,[131073]),

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
   {'IfPDU_fromClient_authRep_localFile', Term1, Term2}.




%%================================
%%  IfPDU_fromClient_authRep_ldap
%%================================
'enc_IfPDU_fromClient_authRep_ldap'(Val, TagIn) ->
   {_,Cindex1, Cindex2} = Val,

%%-------------------------------------------------
%% attribute userId(1) with type PrintableString
%%-------------------------------------------------
   {EncBytes1,EncLen1} = ?RT_BER:encode_restricted_string([], Cindex1, 19, [<<128>>]),

%%-------------------------------------------------
%% attribute pass(2) with type PrintableString
%%-------------------------------------------------
   {EncBytes2,EncLen2} = ?RT_BER:encode_restricted_string([], Cindex2, 19, [<<129>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
?RT_BER:encode_tags(TagIn, BytesSoFar, LenSoFar).
'dec_IfPDU_fromClient_authRep_ldap'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 

%%-------------------------------------------------
%% attribute userId(1) with type PrintableString
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = ?RT_BER:decode_restricted_string(V1,{1,30},19,[131072]),

%%-------------------------------------------------
%% attribute pass(2) with type PrintableString
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = ?RT_BER:decode_restricted_string(V2,{1,30},19,[131073]),

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
   {'IfPDU_fromClient_authRep_ldap', Term1, Term2}.

'dec_IfPDU_fromClient_authRep'(Tlv, TagIn) ->
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 
case (case Tlv1 of [CtempTlv1] -> CtempTlv1; _ -> Tlv1 end) of

%% 'localFile'
    {131072, V1} -> 
        {localFile, 'dec_IfPDU_fromClient_authRep_localFile'(V1, [])};


%% 'ldap'
    {131073, V1} -> 
        {ldap, 'dec_IfPDU_fromClient_authRep_ldap'(V1, [])};

      Else -> 
         exit({error,{asn1,{invalid_choice_tag,Else}}})
   end
.
'dec_IfPDU_fromClient'(Tlv, TagIn) ->
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 
case (case Tlv1 of [CtempTlv1] -> CtempTlv1; _ -> Tlv1 end) of

%% 'subscribe'
    {131072, V1} -> 
        {subscribe, 'dec_Modules'(V1, [])};


%% 'unsubscribe'
    {131073, V1} -> 
        {unsubscribe, 'dec_Modules'(V1, [])};


%% 'version'
    {131074, V1} -> 
        {version, 'dec_Version'(V1, [])};


%% 'authProto'
    {131075, V1} -> 
        {authProto, ?RT_BER:decode_enumerated(V1,[],[{localFile,0},{ldap,1}],[])};


%% 'authRep'
    {131076, V1} -> 
        {authRep, 'dec_IfPDU_fromClient_authRep'(V1, [])};

      Else -> 
         {asn1_ExtAlt, ?RT_BER:encode(Else,nif)}
   end
.


'dec_IfPDU'(Tlv) ->
   'dec_IfPDU'(Tlv, []).

'dec_IfPDU'(Tlv, TagIn) ->
Tlv1 = ?RT_BER:match_tags(Tlv,TagIn), 
case (case Tlv1 of [CtempTlv1] -> CtempTlv1; _ -> Tlv1 end) of

%% 'fromServer'
    {131072, V1} -> 
        {fromServer, 'dec_IfPDU_fromServer'(V1, [])};


%% 'fromClient'
    {131073, V1} -> 
        {fromClient, 'dec_IfPDU_fromClient'(V1, [])};

      Else -> 
         exit({error,{asn1,{invalid_choice_tag,Else}}})
   end
.
